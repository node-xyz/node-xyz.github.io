<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>Node XYZ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
</head>

  <body>
    <section class="page-header">
  <h1 class="project-name"><a style="text-decoration: none; color: inherit"href="/">Node XYZ</a></h1>
  <h2 class="project-tagline">Microservice toolkit for node</h2>
  <a href="https://github.com/node-xyz" class="btn">View on GitHub</a>
  <a href="https://github.com/node-xyz/xyz-core" class="btn">xyz-core</a>
  <a href="https://github.com/node-xyz/xyz-cli" class="btn">xyz-cli</a>
  <a href="/getting-started" class="btn"> Documentation </a>
  <a href="/apidoc" class="btn"> API Doc </a>
</section>


    <section class="main-content">
      
      <h1 id="hello-xyz">Hello XYZ</h1>

<p>This brief tutorial will help you fathom the concepts of XYZ, and help you get started with it.</p>

<h4 id="contents">Contents</h4>

<ul>
  <li><a href="/getting-started#hello-xyz">Hello XYZ</a></li>
  <li><a href="/getting-started#replicating-your-nodes-and-services">Replicate your services</a></li>
  <li><a href="/getting-started#service-discovery">Service Discovery</a></li>
  <li><a href="/getting-started#path-based-service-identification">Path based services</a></li>
  <li><a href="/getting-started#middlewares">Middlewares</a></li>
</ul>

<h3 id="baby-microservice">Baby Microservice</h3>

<p>Assume that we only have two services that will communicate with each other. Suppose that each of these services (aka Node modules) have another API exposed two end users. That is not our business at the moment, since as mentioned before, XYZ will divide the matter of end user and the matter of system. Now, our goal is to focus on what is important to our own system.</p>

<p>The – dummy services are as follows:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// math.ms.js
// a very fancy math module with super fast calculation
function add(x, y) {
return x + y
}

function mul(x, y) {
  return x * y
}

// string.ms.js
// some ultra hard string manipulations
function up(str) {
  return s.toUpperCase()
}
function down(str) {
  return s.toLowerCase()
}
</code></pre>
</div>

<p>Now, assume that these services need to call each other in order to share their services. This is the first place that XYZ will come to action.</p>

<p>In order to have two xyz instances communicate with each other, they need to have a system, a shared system. Information about the system is filled to the xyz instance using a config parameter. The config parameter has information such as local port/it/serviceName and a list of nodes who live inside the system. Note that a node can join the system without being in the static list, this is just a basic example!</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// math.ms.js
// a very fancy math module with super fast calculation
let xyz = require('xyz-core').xyz
let mathMS = new xyz({
  selfConf: {
    name: 'MathMS',
    host: '127.0.0.1',
    port: 3333
  },
  systemConf: {
    microservices: [{
        host: '127.0.0.1',
        port: 3334
      }]
  }
})

// expose these function over the system
mathMS.register('mul', (payload, response) =&gt; {
  response.send(payload.x * payload.y)
})

// expose these function over the system
mathMS.register('add', (payload, response) =&gt; {
  response.send(payload.x + payload.y)
})

// string.ms.js
// some ultra hard string manipulations
let xyz = require('xyz-core').xyz
let stringMS = new xyz({
  selfConf: {
    name: 'stringMS',
    host: '127.0.0.1',
    port: 3334
  },
  systemConf: {
    microservices: [{
        host: '127.0.0.1',
        port: 3333
      }]
  }
})

stringMS.register('up', (payload, response) =&gt; {
  response.send(payload.toUpperCase())
})
stringMS.register('down', (payload, response) =&gt; {
  response.send(payload.toLowerCase())
})
</code></pre>
</div>

<blockquote>
  <p>The entire process of initializing a system and passing all of the parameters seems too much of a duplicate. We agree! check out the best practices section#common.js</p>
</blockquote>

<p>And that’s it! Now, our services are virtually binded to one another and they can call the service that each of them exposed using <code class="highlighter-rouge">.register</code>. The <code class="highlighter-rouge">microservices: [...]</code> key in <strong>systemConf</strong> will declare the list of other nodes that we can connect to. Obviously, they can be local or remote IPs.</p>

<h4 id="a-note-on-terminology">A Note on terminology.</h4>

<p>Words and phrases in XYZ system are explained in Wiki page. Just to recap, each function exposed via <code class="highlighter-rouge">.register</code> is a <em>service</em>.<br />
Each <strong>Node Process</strong>, having a number of services is called a <strong>node</strong> (or in some places a <em>microservice</em>, but its just temporary).</p>

<p>Back to our little system. Now, one of these system can call a service in the other system using the <code class="highlighter-rouge">.call</code></p>

<div class="highlighter-rouge"><pre class="highlight"><code>//stringMS
// note that these callback styles are inherited from node's native http module.
// `resp` is the IncomingMessage instance etc.
// https://nodejs.org/api/http.html#http_class_http_incomingmessage

stringMS.call('mul', {x: 2, y:5}, (err, body, res) =&gt; {
  console.log(`my fellow service responded with ${body}`)
})
</code></pre>
</div>

<p>You should now see an output like:<br />
<code class="highlighter-rouge">my fellow service responded with 10</code></p>

<h3 id="whats-next">What’s next?</h3>

<p>In this example we hardcoded the list of service, so that they can communicate with each other. This is… just about ok. It is not awesome. What would be awesome is to have nodes joining the system dynamically. Yes, that’s what we’re going to do in the Next Section.</p>

<hr />

<h1 id="replicating-your-nodes-and-services">Replicating Your Nodes and Services</h1>

<p>It would have been much more interesting, if we could add nodes dynamically. Good news: we can.</p>

<p>XYZ nodes can join a system, given that they have a [list of] seed node(s). Seed nodes are the entry point to the system. They should check the authority of the incoming node, if required, and pass the list of nodes available inside the system to it, or any other authentication certificate, again, if required. The fact that there are a lots of ‘ <em>if required</em> ‘ phrases in the statement is that all of these steps are optional and the developer can choose to have them. In the most _Wildcard_is scenario, all nodes are public and anyone can join them.</p>

<p>Let’s assume that both the <em>StringMS</em> and <em>MathMS</em> in the previous section do not know each other. That is to say, their list of microservice/nodes in <em>systemConf</em> is empty:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// string.ms.js
let xyz = require('xyz-core').xyz
let stringMS = new xyz({
  selfConf: {
    name: 'stringMS',
    host: '127.0.0.1',
    port: 3334
  },
  systemConf: {
    microservices: []
  }
})

// math.ms.js
let xyz = require('xyz-core').xyz
let mathMS = new xyz({
  selfConf: {
    name: 'MathMS',
    host: '127.0.0.1',
    port: 3333
  },
  systemConf: {
    microservices: []
  }
})
</code></pre>
</div>

<p>Furthermore, let’s assume that the MathMS is the constant node in the system and stringMSs are going to come and go. Go ahead and run the mathMS alone, you will see that nothing happens.</p>

<p>Now run the stringMS. you’ll se that:<br />
<code class="highlighter-rouge">warn :: Sending a message to /mul from first find strategy failed (Local Response)  
my fellow service responded with null</code></p>

<p>The <a href="https://github.com/node-xyz/xyz.service.send.first.find">first find strategy</a> is a default behavior embedded inside node XYZ for finding nodes to send messages to. We’ll see more on this later. The main point is that the message failed. Obviously because StringMS does not know any mathMS at this point!</p>

<p>Change the stringMS to the following, specifying a new seed node for it. Also add a filed in mathMS that will indicate that this node is allowed to admit new nodes:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// string.ms.js
let xyz = require('xyz-core').xyz
let stringMS = new xyz({
  selfConf: {
    name: 'stringMS',
    host: '127.0.0.1',
    port: 3334,
    seed: [{host: '127.0.0.1', port: 3333}]
  },
  systemConf: {
    microservices: []
  }
})

// math.ms.js
let xyz = require('xyz-core').xyz
let mathMS = new xyz({
  selfConf: {
    allowJoin: true,
    name: 'MathMS',
    host: '127.0.0.1',
    port: 3333
  },
  systemConf: {
    microservices: []
  }
})
</code></pre>
</div>

<p>Now, the two nodes have no knowledge of each other, yet they can join and work with each other. Go ahead and run the MathMS, next run the stringMS in a separate terminal and see the results. As you see, the output is still the same.</p>

<p>This get’s even more interesting when we add more nodes. You can add more stringMS nodes and see that all of them will eventually find the MathMS and can connect with them. There is only one small problem. All stringMSs are configured to use one port. Hopefully, XYZ provides a way to override any configuration, for debugging purposes mainly. We’ll cover this later, but, for now, you can use the <code class="highlighter-rouge">--xyzport</code> command line argument to override the port. Run many many more StringMS instances with:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ node math.ms.js --xyzport 5000
$ node math.ms.js --xyzport 5001
$ node math.ms.js --xyzport 5002
...
</code></pre>
</div>

<p>If you are more interested to see how nodes actually work with each other, see the ()[Service Discovery and Ping] section.</p>

<p>A question might come to mind at this point. We have many sender nodes, and only just one receiver node in this example, so… it is kind obvious how each request gets routed. Assume that we have two receiver nodes (mathMS) and a dozen sender nodes, how could we decide on one of the mathMSs?</p>

<p>You might argue that this is a matter that xyz should handle. Indeed, we do handle it. it’s just that we are very keen to make you familiarized whit what’s happening under the hood, so that you can change it when required.</p>

<p>In order to have different message routing ways, xyz supports to mechanisms:</p>

<ol>
  <li>Service Discovery middlewares</li>
  <li>Path based service identification</li>
</ol>

<p>The upcoming sections will describe these concepts.</p>

<p>Before going into the next section, you might argue that why is this so important? In a microservice-based system, it is crucially important!</p>

<p>If you think about the system as a whole, you come to realize that many many types of messages might be sent. One node might want to broadcast a message to <strong>all other nodes</strong>, or to a subset of them. A node might want to apprise just a few database nodes about a record update, and many many more events that might happen!</p>

<p>If you are not convinced about this, I highly recommend you to read the <a href="https://github.com/node-xyz/xyz-core/wiki/">Wiki</a> page of xyz-core, specially the one about <a href="https://github.com/node-xyz/xyz-core/wiki/Microservices%3F-What%3F">microservices</a>.</p>

<h1 id="service-discovery">Service Discovery</h1>

<p>As mentioned in the previous section, the process of choosing a destination node when making a call is rather difficult and obscure. XYZ provides a configuration for each of the nodes, so that each node can actually choose a strategy for sending a message.</p>

<p>The good thing about these plugins is that they are completely modifiable. That is to say, you can write your own strategy and patch it into your system!</p>

<p>XYZ currently has two trivial approaches implemented as plugins. Let’s look at one of them <a href="https://github.com/node-xyz/xyz.service.send.first.find/blob/master/call.middleware.first.find.js">here</a> :</p>

<div class="language-javascript highlighter-rouge"><pre class="highlight"><code><span class="c1">// Built in winston instances</span>
<span class="kr">const</span> <span class="nx">logger</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'xyz-core'</span><span class="p">).</span><span class="nx">logger</span>
<span class="kr">const</span> <span class="nx">Path</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'xyz-core'</span><span class="p">).</span><span class="nx">path</span>
<span class="kr">const</span> <span class="nx">http</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'http'</span><span class="p">)</span>

<span class="kd">function</span> <span class="nx">firstFind</span> <span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">servicePath</span> <span class="o">=</span> <span class="nx">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="nx">userPayload</span> <span class="o">=</span> <span class="nx">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
    <span class="nx">foreignNodes</span> <span class="o">=</span> <span class="nx">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
    <span class="nx">transportClient</span> <span class="o">=</span> <span class="nx">params</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="nx">responseCallback</span> <span class="o">=</span> <span class="nx">params</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">node</span> <span class="k">in</span> <span class="nx">foreignNodes</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">matches</span> <span class="o">=</span> <span class="nx">Path</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="nx">servicePath</span><span class="p">,</span> <span class="nx">foreignNodes</span><span class="p">[</span><span class="nx">node</span><span class="p">])</span>
    <span class="nx">logger</span><span class="p">.</span><span class="nx">debug</span><span class="p">(</span><span class="err">`</span><span class="nx">FIRST</span> <span class="nx">FIND</span> <span class="err">::</span> <span class="nx">determined</span> <span class="nx">matches</span> <span class="nx">$</span><span class="p">{</span><span class="nx">matches</span><span class="p">}</span> <span class="k">in</span> <span class="nx">node</span> <span class="nx">$</span><span class="p">{</span><span class="nx">node</span><span class="p">}</span> <span class="k">for</span> <span class="nx">$</span><span class="p">{</span><span class="nx">servicePath</span><span class="p">}</span><span class="err">`</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">matches</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">logger</span><span class="p">.</span><span class="nx">debug</span><span class="p">(</span><span class="err">`</span><span class="nx">FIRST</span> <span class="nx">FIND</span> <span class="err">::</span> <span class="nx">determined</span> <span class="nx">node</span> <span class="k">for</span> <span class="nx">service</span> <span class="nx">$</span><span class="p">{</span><span class="nx">servicePath</span><span class="p">}</span> <span class="nx">by</span> <span class="nx">first</span> <span class="nx">find</span> <span class="nx">strategy</span> <span class="nx">$</span><span class="p">{</span><span class="nx">node</span><span class="p">}</span><span class="err">:</span><span class="nx">$</span><span class="p">{</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span><span class="err">`</span><span class="p">)</span>
      <span class="nx">transportClient</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">matches</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">node</span> <span class="p">,</span> <span class="nx">userPayload</span><span class="p">,</span> <span class="nx">responseCallback</span><span class="p">)</span>
      <span class="nx">done</span><span class="p">()</span>
      <span class="k">return</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// if no node matched</span>
  <span class="nx">logger</span><span class="p">.</span><span class="nx">warn</span><span class="p">(</span><span class="err">`</span><span class="nx">Sending</span> <span class="nx">a</span> <span class="nx">message</span> <span class="nx">to</span> <span class="nx">$</span><span class="p">{</span><span class="nx">servicePath</span><span class="p">}</span> <span class="nx">from</span> <span class="nx">first</span> <span class="nx">find</span> <span class="nx">strategy</span> <span class="nx">failed</span> <span class="p">(</span><span class="nx">Local</span> <span class="nx">Response</span><span class="p">)</span><span class="err">`</span><span class="p">)</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">responseCallback</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">responseCallback</span><span class="p">(</span><span class="nx">http</span><span class="p">.</span><span class="nx">STATUS_CODES</span><span class="p">[</span><span class="mi">404</span><span class="p">],</span> <span class="kc">null</span><span class="p">,</span> <span class="kc">null</span><span class="p">)</span>
    <span class="nx">done</span><span class="p">()</span>
    <span class="k">return</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">module</span><span class="p">.</span><span class="nx">exports</span> <span class="o">=</span> <span class="nx">firstFind</span>
</code></pre>
</div>

<p>We really don’t want to go too deep inside this code at the time, but you can get a general feeling about it that a <code class="highlighter-rouge">Path</code> object will eventually find a list of nodes that can response to a certain <code class="highlighter-rouge">servicePath</code> and calls the first one:</p>

<p><code class="highlighter-rouge">transportClient.send(matches[0], node , userPayload, responseCallback)</code>.</p>

<p>whenever you call <code class="highlighter-rouge">someMs.call('foo' , ()=&gt;{} )</code> in your code, somewhere along the path, this function will be called and it will find one destination node and invokes a transport client with it. Transport client is the actual module that will make the HTTP/TCP call to destination node.</p>

<blockquote>
  <p>This structure, a function with parameters passed as array, with <code class="highlighter-rouge">next</code> and <code class="highlighter-rouge">done</code> callbacks is actually the <strong>middleware</strong> signature of XYZ. We’ll learn soon about middleware in this tutorial.</p>
</blockquote>

<blockquote>
  <p>Change your string ms to call an invalid service, say, <code class="highlighter-rouge">.call('blahblah', () =&gt; {})</code>. Now look at the warning logs. Now look at the end of this plugin :
<code class="highlighter-rouge">logger.warn("Sending a message to ${servicePath} from first find strategy failed (Local Response)")</code>
Are you seeing what I am seeing too?</p>
</blockquote>

<p>XYZ is configured to work with this module by default. if you wish to change them, a new key named <strong><code class="highlighter-rouge">defaultSendStrategy</code></strong> should be added to the configuration object passed to xyz constructor.</p>

<p>In order to test this feature, let’s use another send strategy, <strong>send.to.all</strong>. You can find the plugin <a href="https://github.com/node-xyz/xyz.service.send.to.all">here</a>.</p>

<p>First, include this plugin inside your working directory:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>npm install xyz.service.send.to.all
</code></pre>
</div>

<p>Next, we are going to run three math services, and a dozen of string services. The configurations are similar to the previous section. We only have to configure string.ms to use <code class="highlighter-rouge">xyz.service.send.to.all</code> :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// math.ms.js
// same as before


// string.ms.js
let sendToAll = require('xyz.service.send.to.all')

let stringMS = new xyz({
  defaultSendStrategy: sendToAll,
  selfConf: {
    name: 'stringMS',
    host: '127.0.0.1',
    port: 3334,
    seed: [{host: '127.0.0.1', port: 3333}]
  },
  systemConf: {
    microservices: []
  }
})

...

// our responses are going to be from few possible nodes, hence they are objects from now on!
// use JSON.stringify instead.
setInterval(() =&gt; {
  stringMS.call('mul', {x: 2, y: 5}, (err, body, res) =&gt; {
    console.log(`my fellow service responded with ${JSON.stringify(body)}`)
  })
}, 2000)

</code></pre>
</div>

<p>First, run the math ms and string ms like before. The string ms will join the math ms. First point is that now, our responses are different, it has been indicated the this values has been responded form which node.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>my fellow service responded with {"127.0.0.1:3333:/mul":[null,10]}
</code></pre>
</div>

<p>in each array response, the first index is the error and the second one is the actual response.</p>

<p>Now go ahead and run a new math.ms. An old response happens here again. We need the new instance of Math ms to have a seed node, yet, we didn’t include it in it’s configuration.</p>

<p>Similar to how we can override the port number, a single seed node can also be added by command line argument. Run the new math Ms :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>node math.ms.js --xyzport 5000 --xyzseed "127.0.0.1:3333"
node math.ms.js --xyzport 5001 --xyzseed "127.0.0.1:3333"
</code></pre>
</div>

<p>after just a few seconds, the log of string ms should change to</p>

<div class="highlighter-rouge"><pre class="highlight"><code>my fellow service responded with {
    "127.0.0.1:3333:/mul":[null,10],
    "127.0.0.1:5000:/mul":[null,10],
    "127.0.0.1:5001:/mul":[null,10]
}
</code></pre>
</div>

<p>In fact, if you close one of the mathMSs, you’ll see the response to be:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>my fellow service responded with {
  "127.0.0.1:5001:/mul":[
    {"code":"ECONNREFUSED","errno":"ECONNREFUSED","syscall":"connect","address":"127.0.0.1","port":5001},
    null
  ],
  "127.0.0.1:3333:/mul":[null,10],
  "127.0.0.1:5000:/mul":[null,10]}
</code></pre>
</div>

<p>As you see, the first parameter is the error and the second parameter is the response. This happens because each node will not immediately assume that another node is offline after one failure. The process and parameters of node failure will be discussed later.</p>

<p>So … are you not liking the way that send to all is functioning? I mean, who would respond with an array like that? This is actually what we hoped for!  this plugin is just a test plugin that we used in our development. You can easily change it to whatever you like.</p>

<p>For example, you can modify <a href="https://github.com/node-xyz/xyz.service.send.to.all/blob/master/call.send.to.all.js#L31">this line</a> to get rid of the annoying error.</p>

<p>Another interesting send strategy that you might want to implement and test is majority function. You can change the <code class="highlighter-rouge">send.to.all</code> in a way that it will send the message to all nodes, will wait for all responses, and will return with a single result, if all if the responses from different services were the same. If not, it will return an Error. Who knows, maybe you actually use this Microservice to do floating point calculations. Each machine handles floating point differently and the responses might actually differ!</p>

<h1 id="path-based-service-identification">Path based service identification</h1>

<p>Aside from Service discovery procedures, xyz provides another way to make service invocation even more flexible. It’s called <strong>Path Base</strong> service identification. That is to say, each service, aka. function that you expose, will be exposed on a certain path on that process. So far we have used a plain string as the service name. The truth is that those were paths too! XYZ has been adding a single <code class="highlighter-rouge">/</code> to each of them. Recall one of the logs printed from the previous section. Look at it again:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  "127.0.0.1:5000:/mul":[null,10]}
</code></pre>
</div>

<p>As you see, the actual identifier of the service is actually: <strong>[IP]:[PORT]:/[PATH]</strong>.</p>

<p>As a naive example, let’s assume that our math service is super accurate and can add floating point numbers up to thousands of decimal points. But we don’t want to waste resource on simple integer arithamtic. Hence, we will devide our services into to section:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>decimal/add
decimal/mul

float/add
float/add
</code></pre>
</div>

<p>Applying this turns out to be very easy!</p>

<p>Change the address of each function is mathMS:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>mathMS.register('decimal/mul', (payload, response) =&gt; {
  response.send(payload.x * payload.y)
})

mathMS.register('decimal/add', (payload, response) =&gt; {
  response.send(payload.x + payload.y)
})

mathMS.register('float/mul', (payload, response) =&gt; {
  // let's add the float casting, just fore sake of our example!
  response.send(parseFloat(payload.x * payload.y))
})

mathMS.register('float/add', (payload, response) =&gt; {
  response.send(parseFloat(payload.x + payload.y))
})
</code></pre>
</div>

<p>If you run the stringMS now, it will get only <code class="highlighter-rouge">null</code>. This is natural because it is looking for <code class="highlighter-rouge">/mul</code>, while it only knows <code class="highlighter-rouge">/decimal/mul</code>.</p>

<p>Next, change the call path in stringMS:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>setInterval(() =&gt; {
  stringMS.call('/decimal/mul', {x: 2, y: 5}, (err, body, res) =&gt; {
    console.log(`my fellow service responded with ${JSON.stringify(body)}`)
  })
}, 2000)
</code></pre>
</div>

<p>As you see, now we get the same result.</p>

<p>The main purpose of paths is to allow:</p>

<ol>
  <li>better grouping and organization among services.</li>
  <li>allow more meaningful names and identification</li>
  <li>allow grouping call:</li>
</ol>

<p>That’s right. You can also use the combination of <code class="highlighter-rouge">xyz.call.send.to.all</code> plugin and paths to call multiple services:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>setInterval(() =&gt; {
  stringMS.call('/decimal/*', {x: 2, y: 5}, (err, body, res) =&gt; {
    console.log(`my fellow service responded with ${JSON.stringify(body)}`)
  })
}, 2000)
</code></pre>
</div>

<p>Now our response is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>my fellow service responded with {
  "127.0.0.1:3333:/decimal/mul":[null,10],
  "127.0.0.1:3333:/decimal/add":[null,7]
}
</code></pre>
</div>

<blockquote>
  <p>Note that this example is working only because we are using <code class="highlighter-rouge">xyz.call.send.to.all</code> as send strategy is StringMS.</p>
</blockquote>

<p>Go ahead and try things like <code class="highlighter-rouge">*/mul</code> or even <code class="highlighter-rouge">/*/*</code>.</p>

<h4 id="note-on-valid-paths-and-wildcards">Note on valid Paths and wildcards</h4>

<p>Currently, XYZ path parser only supports charachters and wildcards in paths. That is to say, when creating a new service, the valid regex is:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>/^(\/([a-zA-Z]|[1-9]|\*)+)*$/
</code></pre>
</div>

<p>and when calling a service, you can only call definite paths or full-wildcards. <code class="highlighter-rouge">abc/*/abc</code> is valid, albeit <code class="highlighter-rouge">abc/ab*/abc</code> is not. This is a work in progress and will change in the upcoming version.</p>

<h1 id="middlewares">Middlewares</h1>

<p>Middlewares are nothing new to you. You have already seen them. <code class="highlighter-rouge">xyz.service.send.to.all</code> was a simple middleware in xyz system. In this section we are going to get into the details of middleware and use them to develop an authentication mechanisms.</p>

<h3 id="middlewares-and-layers-in-xyz">Middlewares and Layers in XYZ</h3>

<p>So far, our system has been plain open! No authentication. That is not good. The good news is that XYZ does not provide any authentication mechanisms by default. You heard me, <strong>No authentication mechanisms</strong>. As opposed to application-dependent steps like authentication which are not compulsory in xyz, middlewares are. That is to say, whatever happens, requests will go through a middleware in xyz.</p>

<p>In order to understand the place and organization of middleware in xyz, you should get a bit more familiar with it. A brief summery of the architecture of xyz is proivded in the <a href="https://github.com/node-xyz/xyz-core/wiki/XYZ-in-a-nutshell#the-close-up-picture">wiki page of xyz-core</a>. before going any further, read it carefully.</p>

<p>As you return to this page, you should have a superficial knowledge about how xyz middlewares works and where they are. Just to recap:</p>

<blockquote>
  <p>XYZ consists of 3 main layers. <code class="highlighter-rouge">xyz-core</code>, <code class="highlighter-rouge">Service-Repository</code> and <code class="highlighter-rouge">Transport</code>. The pipeline that will communicate a message from one layer to another is a <strong>middleware</strong>.</p>
</blockquote>

<p>Furthermore,</p>

<blockquote>
  <p>Three main middlewares exist in xyz. Two of which are invoked when a call is being sent and one when a call is being received:</p>
  <ul>
    <li>Service Level CallDispatchMiddlewareStack</li>
    <li>Transport Layer CallDispatchMiddlewareStack</li>
    <li>Transport Layer CallReceiveMiddlewareStack</li>
  </ul>
</blockquote>

<p>As a final recap:</p>

<p><img src="https://raw.githubusercontent.com/node-xyz/xyz-core/master/media/mw.png" alt="Overall structure of XYZ" /></p>

<h3 id="middleware-stacks">Middleware Stacks</h3>

<p>Middlewares are implemented using the GenericMiddlewareHandler Class in XYZ. this class will register an array of functions and passes an object (aka. parameters) through this array of middlewares.</p>

<div class="highlighter-rouge"><pre class="highlight"><code>MiddlewareStack : [Function, Function, Function, ... , Function]
</code></pre>
</div>

<p>As an example, Whenever a request is received and parsed in Transport Layer, a middleware function will pass it to the Service repository layer. This action will happen in the last function placed in the last index of CallReceiveMiddlewareStack in Transport layer.</p>

<blockquote>
  <p>Due to the fact that critical actions such as passing a request object to the upper/lower layer or passing a request out to the HTTP layer happen in middleware, it is crucially important to be very careful with them. Specifically, some middlewares are placed in xyz by default. They should remain in their place, unless you have a good reason to remove them.</p>
</blockquote>

<p>As an example, as mentioned above, the middleware placed between Transport layer and Service-Repository layer has such initial state:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// Initial state of CallReceiveMiddlewareStack
[Funciton():passToTransportLayer]
</code></pre>
</div>

<p>This enables us to prepend more functions to this array and perform any type of process. After seeing the syntax structure of each middleware in the next section, we will actually use this to add a generic authentication middleware to our system.</p>

<h3 id="middleware-syntax">Middleware syntax</h3>

<p>As mentioned above, each middleware is nothin but a function. In order to examine the parameters of this function, let’s write a bare-bone middleware.</p>

<p>The key structure of a middleware is as follows:</p>

<ul>
  <li>A middleware should be exported as a function</li>
  <li>The function will take three parameters:
    <ul>
      <li><code class="highlighter-rouge">params</code>: an array of parameters values passed to the middleware function.</li>
      <li><code class="highlighter-rouge">next</code>: function that will ignore the rest of the execution of this middleware and invoke the next function in the stack.</li>
      <li><code class="highlighter-rouge">end</code>: will end of the execution of the entire stack.</li>
    </ul>
  </li>
</ul>

<p>Keeping this ideas in mind, let’s write a simple logger middleware:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>let dummyLogger = function(params, next, end) {
  console.log('i was called! now what?')
  console.log(params[0])
  console.log(params[1])
  next()
}
module.exports = dummyLogger;
</code></pre>
</div>

<p>This is the minimum structure required for each middleware.</p>

<p>Next important step is to know what is the content of <code class="highlighter-rouge">params</code>.</p>

<p>Each middleware in xyz has specific params structure. As an example, The transport layer call dispatch middleware has the following parameters according to the <a href="https://github.com/node-xyz/xyz-core/blob/master/src/Transport/HTTP/http.client.js#L35">source code</a>: <code class="highlighter-rouge">[requestConfig, callResponseCallback]</code>. That means that the first index is a variable containing request information and the second parameter is the callback function for this call.</p>

<blockquote>
  <p>Remember how you call something like <code class="highlighter-rouge">someMS.call('somePath', ()=&gt; {})</code>? The second argument to this call is the actual callback function that will be passed to the Transport layer, and you have access to it inside the middleware. This is because the last index of this middleware stack is a function <a href="">that will wrap this request in an http object and pass it to the network</a>. Therefore, it needs the callback function to invoke it when the response is back. Note that this middleware is embedded in xyz and it is not on a separate repository, unlike other middlewares.</p>
</blockquote>

<p>Next, let us see how we can insert this dummy logger to the system. The XYZ interface provides methods for inserting a function to a specific index of a specific MiddlewareStack. As an example, we can insert this middleware in StringMS (continuing from the previous section):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// StringMS
stringMS.middlewares().transport.callDispatch.register(0, require('./dummy.logger'))

// stringMS.register() ...
</code></pre>
</div>

<p>note that in this function, the first parameter is the index in middleware stack. This call will insert the new function to the first index and will push all other functions to the next index. If you want to remove a specific middleware, <a href="https://node-xyz.github.io/apidoc/GenericMiddlewareHandler.html">use</a><code class="highlighter-rouge">.remove(idx)</code>.</p>

<p>Check your logs after running the system in any desired configuration, one StringMS and one MathMS for sake of simplicity:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[Function: bound ]
i was called! now what?
{ hostname: '127.0.0.1',
  port: '3333',
  path: '/call',
  method: 'POST',
  json: { userPayload: { x: 2, y: 5 }, service: '/float/mul' } }
[Function: bound ]
my fellow service responded with {"127.0.0.1:3333:/decimal/mul":[null,10],"127.0.0.1:3333:/float/mul":[null,10]}
</code></pre>
</div>

<p>As you see, our new middleware was invoked before the response was sent.</p>

<p>The parameters are also now clear. Note that except the payload, all of these parameters will be used in the last middleware to create and send a HTTP request. Altering them will indeed have consequences. Albeit, not all alterations are harmful. As an example, consider the following scenarios:</p>

<ul>
  <li>Applying a pre/post-processing to all request</li>
  <li>logging systems</li>
  <li>validation (note that by calling <code class="highlighter-rouge">end()</code>, the request will be dismissed)</li>
  <li>reusability of middlewares</li>
  <li>more decoupling: means that not only that your application logic is separated from your xyz service code, your configurations, which are implemented in the middlewares are also decoupled from the xyz service code.</li>
</ul>

<p>Note that the <code class="highlighter-rouge">json</code> key is a generic place to put data in it. But, only the <code class="highlighter-rouge">userPayload</code> will be available to the receiver.</p>

<ul>
  <li>last but not least! authentication. Although this is analogous to validation, we are going to mention it separately since we are going to implement one in the next section:</li>
</ul>

<h3 id="an-authentication-middleware">An authentication middleware:</h3>

<p>Suppose that your system uses a very simple  authentication system, kind of a shared-secret mechanism. You want authentication to happen in Transport layer. This is generally better because the Transport layer can drop unauthorized requests immediately and the Service-Repository layer, which is more critical, won’t be bothered to check them twice.</p>

<p>We are going to place two middlewares in Transport layer for this purpose, namely in <strong>CallReceiveMiddlewareStack</strong> and <strong>CallDispatchMiddlewareStack</strong>.</p>

<p>The code of these middlewares should be fairly understandable to you now. The sender side is fairly (perhaps more than <em>fairly</em>) simple:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>const SECRET = 'SECRET'

let authSend = function (params, next, end) {
  params[0].json.authorization = SECRET
  next()
}

module.exports = authSend;
</code></pre>
</div>

<p>The only point to notice in the receiving side is that the params are a bit different. This is natureal because the middleware stack that will be invoked is directly getting its values and params from <strong>Node HTTP module</strong>. Hence, the params are similar to node networking and are as follows:</p>

<ul>
  <li><strong>params[0]</strong> the request object. Similiar to node’s <a href="">IncomingMessage</a></li>
  <li><strong>params[1]</strong> the response object. The wrapper used to send a response to the sender.</li>
  <li><strong>params[2]</strong> body. The payload of the request. Note that this is the entire <code class="highlighter-rouge">json</code> key which was available in the sending side. Later, another middleware will only pass the userPayload section of this object the service repository and the service repository will pass it to the user. Thus, the authorization key that we added in the last section is entirely hidden from the application code.</li>
</ul>

<p>Hence, the receiving side of the middleware is similar to this:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>const SECRET = 'SECRET'

let authReceive = function (params, next, end) {
  let authorization = params[2].authorization

  if (authorization === SECRET) {
    console.log('auth accepted')
    next()
  }else {
    console.log('auth failed')
    // it's better to also close the request immediately
    params[0].destroy()
    end()
  }
}

module.exports = authReceive

</code></pre>
</div>

<p>Similarly, we can insert these middlewares into the system using:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>// stringMS
stringMS.middlewares().transport.callDispatch.register(0, require('./auth.send'))
stringMS.middlewares().transport.callReceive.register(0, require('./auth.receive'))

// mathMS
mathMS.middlewares().transport.callDispatch.register(0, require('./auth.send'))
mathMS.middlewares().transport.callReceive.register(0, require('./auth.receive'))
</code></pre>
</div>

<p>Again, note that what you add to the <code class="highlighter-rouge">json</code> key is not available to the application layer. That is to say, you do not need to explicitly delete it from the object. Add a log to the receiving function and and double check this.</p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="">Node XYZ</a> is maintained by <a href="">Kian Peymani</a>.</span>
  <small><span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span></small>
</footer>


    </section>

  </body>
</html>

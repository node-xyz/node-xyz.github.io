<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="UTF-8">
  <title>Servers and Routes - Node XYZ </title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/assets/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/assets/css/theme.css">
  <link rel="stylesheet" href="/assets/css/syntax.css">
  <!-- <link rel="stylesheet" href="/assets/css/main.css"> -->
  <link rel="stylesheet" href="/assets/css/stylish.css">
  <link rel="stylesheet" href="http://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">

  <script
    src="https://code.jquery.com/jquery-3.1.1.min.js"
    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
    crossorigin="anonymous"></script>

</head>

<body>

<style media="screen">
body {
  background-color: var(--light-color);
  color: var(--dark-color)
}
</style>
<style media="screen">
/* Nav */
#mainNav {
  color: var(--light-color) !important;
}

</style>

<nav class="navbar navbar-inverse" style="margin:0" id="mainNav">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand spacing" href="/">NODE XYZ</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Repositories <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="padding"> CORE REPOSITORIES </li>
            <li><a href="https://github.com/node-xyz/xyz-core" class="spacing">xyz.core</a></li>
            <li><a href="https://github.com/node-xyz/xyz-cli" class="spacing">xyz.cli</a></li>
            <li role="separator" class="divider"></li>
            <li class="padding"> ADDITIONAL </li>
            <li><a href="https://github.com/node-xyz/xyz.monitor.basic.bootstrap" class="spacing">xyz.monitor</a></li>
            <li><a href="https://github.com/node-xyz/xyz.ping.swim.bootstrap" class="spacing">xyz.ping.swim</a></li>
            <li><a href="https://github.com/node-xyz/xyz.ping.stochastic.bootstrap" class="spacing">xyz.ping.stochastic</a></li>
          </ul>
        </li>
      </ul>

      <ul class="nav navbar-nav navbar-left">
        <!-- <li><a href="#">Link</a></li> -->
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> Documentations <span class="caret"></span></a>
          <ul class="dropdown-menu">
            <li class="padding"> READING </li>
            <li><a href="/documentations/getting-started">Getting Started</a></li>
            <li><a href="/documentations/advance">Advance Topics</a></li>
            <li><a href="/apidoc">API DOC</a></li>
            <li role="separator" class="divider"></li>
            <li class="padding"> EXAMPLES </li>
            <li class="spacing"><a href="https://github.com/node-xyz/xyz.example.getting.started">xyz.getting.started</a></li>
            <li class="spacing"><a href="https://github.com/node-xyz/xyz.example.logger.bootstrap">xyz.logger.bootstrap</a></li>
            <li class="spacing"><a href="https://github.com/node-xyz/xyz.example.auth.basic.receive">xyz.auth.basic.receive</a></li>
            <li class="spacing"><a href="https://github.com/node-xyz/xyz.example.auth.basic.send">xyz.auth.basic.send</a></li>
          </ul>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<section class="container">

  <ol class="breadcrumb" style="margin: 10px; color: white;">
    <li><a class='spacing' href="/">Node XYZ </a></li>
    
    
    
    
    
    
    
    

    
      

    
      
      
      <li >
        <a style="color: inherit" href="/documentations/">documentation</a>
      </li>
      
      

    
      

    
      

    
      

    
      

    
      

    
      

    
      

    
      

    
      
      
    
    
    
    

    
      

    
      

    
      
      
      <li >
        <a style="color: inherit" href="/documentations/advance/">advance</a>
      </li>
      
      

    
      

    
      

    
      

    
      

    
      

    
      

    
      

    
      
      
    
    
    
    

    
      

    
      

    
      

    
      
      
      <li class="active">
        <a style="color: inherit" href="/documentations/advance/server-route/">servers and routes</a>
      </li>
      
      

    
      

    
      

    
      

    
      

    
      

    
      

    
      
      
    </ol>

    <hr>


    <div class="row">
  <div class="col col-md-2" id="__side">
    <div id="___side">
      <p class="spacing"> CONTENTS </p>
      <ol style="padding-left:5px">
      </ol>

    </div>
  </div>

  <div class="col col-md-10">
    <h1 id="servers-and-routes">Servers and Routes</h1>

<p>XYZ nodes are highly transparent to their Transport layer mechanism. In other words, inside the business logic of your application, you need to know <strong>the minimum about the underlying Transport layer of your message</strong>. The only information that you <strong>can</strong> provide to determine your transport type, which is optional, is defining an outgoing route/middleware for the message. We will learn about how to do this in this tutorial.</p>

<blockquote>
  <p>“Transport independence is the ability to move messages from one microservice to another without requiring microservices to know about each other”</p>

  <p>– Richard Rodger. The Tao of Microservices</p>
</blockquote>

<p>This Article can be divided into two sections:</p>
<ol>
  <li><strong>Outgoing Routes</strong>: an abstraction for different ways to send messages.</li>
  <li><strong>Server Routes</strong>: an abstraction for different ways to receive a message.</li>
</ol>

<p>We will start by discussing the former one.</p>

<h1 id="outgoing-routes">Outgoing Routes</h1>

<p>Each node in xyz has the ability to have multiple outgoing routes. This means that a node can send a message only using one of these outgoing routes. <strong>No message can be sent without going through an outgoing route and middleware</strong>. Each outgoing route is linked with an <strong>outgoing middleware stack</strong>. This means that each route can have different middleware functions, hence allowing you to <strong>separate your concerns</strong>. As an example, some messages might need to have encryption and some might not. In this case you can create two outgoing routes in your node, one for encrypted messages:</p>

<p><code class="highlighter-rouge">encrypted.message.mw: [/ENC] [_encrypt_message() -&gt; _httpExport()]</code></p>

<p>and one for normal messages:</p>

<p><code class="highlighter-rouge">public.message.mw: [/PUB] [_httpExport()]</code></p>

<p>In this case, all of the messages that you send using <code class="highlighter-rouge">encrypted.message.mw</code> will be encrypted and sent out over https, while other messages using <code class="highlighter-rouge">public.message.mw</code> will be immediately exported using normal http.</p>

<p>To further simplify this, let’s have another look at the image that shows the generalized architecture of <code class="highlighter-rouge">xyz-core</code>:</p>

<p><img src="/assets/img/arch-c.png" alt="" /></p>

<p>You should only pay attention to the right side of this image. As you see, This image shows a node with two outgoing routes, one having three middlewares and the other having just one. No need to say, the last function in any Transport layer middleware stack should be a function that <strong>actually sends the message</strong>, such as <code class="highlighter-rouge">_httpExport</code> or <code class="highlighter-rouge">_udpExport</code>.</p>

<p>A question might come to mind at this point. Aside from being linked to middleware, is a <strong>xyz outgoing route’s URL</strong>, like <code class="highlighter-rouge">/foo</code> and <code class="highlighter-rouge">/bar</code> in the image, actually analogous to a <strong>physical URLs</strong>, like http routes?</p>

<p>The answer is both yes and no, but you should consider it a <strong>no</strong>. This is because physical routes are meaningless if xyz is using anything other than HTTP. The truth is that in the case of HTTP, xyz will map these <strong>outgoing routes</strong> to <strong>physical routes</strong>, but, nonetheless, in other Transport mechanisms it will inject them to the payload of the message and the receiver will also extract them from the payload, not the URL.</p>

<blockquote>
  <p>Generally, you should consider xyz’s outgoing route’s URLs as an <strong>identifier</strong> of a particular middleware, not a physical route.</p>
</blockquote>

<p>To wrap our introduction of outgoing routes, let’s talk about the default routes in a node:</p>

<p>If you run a barebones xyz node and <code class="highlighter-rouge">console.log</code> it:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">XYZ</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./../../index'</span><span class="p">)</span>

<span class="kd">let</span> <span class="nx">math</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XYZ</span><span class="p">({})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">math</span><span class="p">)</span></code></pre></figure>

<p>you will see the output :</p>

<div class="highlighter-rouge"><pre class="highlight"><code>____________________  TRANSPORT LAYER ____________________
Transport:
  outgoing middlewares:
    call.dispatch.mw [/CALL] || _httpExport[0]
    ping.dispatch.mw [/PING] || _httpExport[0]
...
</code></pre>
</div>

<p>xyz will always create one default route in a system with the identifier/route <code class="highlighter-rouge">/CALL</code>. this route will be used by default whenever you send a message using <code class="highlighter-rouge">.call()</code>. We will soon see how you can change this behavior and send messages to other routes, but first we need to continue this discussion from the other end of a message’s path and talk about <strong>Server Routes</strong>.</p>

<blockquote>
  <p>The routes indicated by <code class="highlighter-rouge">/PING</code> are created using the default ping bootstrap function. if you create a node with <code class="highlighter-rouge">let ms = new XYZ({selfConf: defaultBootstrap: false})</code> you will see that it will not be created. More on this in the <a href="/documentations/advance/ping">Ping</a> section</p>
</blockquote>

<h1 id="server-routes">Server Routes</h1>

<p>Each xyz node can have multiple servers of different type. This allows the same <strong>separation of concerns</strong> that we mentioned in the previous section from one level higher. That is to say, each node can have several servers and each server can have several <strong>server routes</strong>. As an example, you can see in the values of <a href="https://github.com/node-xyz/xyz-core/blob/master/src/Config/Constants.js">default configurations</a> that each node will be created with one HTTP server on port 4000 with one default route <code class="highlighter-rouge">/CALL</code>:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>HTTPServer @ 4000 ::
  Middlewares:
  call.receive.mw [/CALL] || _httpMessageEvent[0]
  ping.receive.mw [/PING] || _pingEvent[0]
</code></pre>
</div>

<blockquote>
  <p>Like the previous section, the <code class="highlighter-rouge">/PING</code> route is created by <code class="highlighter-rouge">ping.default</code> bootstrap function, not <code class="highlighter-rouge">xyz-core</code>.</p>
</blockquote>

<p>Similar to each <strong>outgoing server’s last index</strong>, which <strong><em>should have been</em></strong> an actual <strong>transmission</strong>, the last index of every server route <strong><em>should be</em></strong> an <strong>event</strong>. This event will then be caught by the service layer to invoke the appropriate function.</p>

<p>You can look at the image of the previous section to recap this information in the architecture. In the image, the node has two servers, namely one <strong>HTTP</strong> and one <strong>UDP</strong>, each having two routes with distinct middlewares. No need to say, each of these servers must have a unique <strong>Port</strong>. Ports are particularly important to fathom in xyz because they are a part of the node’s identifier. recalling from previous tutorials, each node’s identifier is:</p>

<p><strong>[IP]:[PORT]</strong></p>

<p>and quoting from <a href="documentations/getting-started">getting started section</a>:</p>

<blockquote>
  <p>the actual <strong>identifier of the service</strong> is actually: <strong>[IP]:[PORT]:/[PATH]</strong>.</p>
</blockquote>

<p>Having multiple servers can cause confusion, since each node is listening on several ports. To resolve this issue, xyz establishes a contract between all components, declaring that <strong>each node’s identifier is determined by the port if its first Transport server</strong>. A method in <code class="highlighter-rouge">xyz-core</code> layer depicts this contract:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">XYZ</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./../../index'</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">math</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XYZ</span><span class="p">({})</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nx">id</span><span class="p">())</span></code></pre></figure>

<p>and you see:</p>

<div class="highlighter-rouge"><pre class="highlight"><code><span class="p">{</span><span class="w"> </span><span class="err">name:</span><span class="w"> </span><span class="err">'node-xyz-init',</span><span class="w">
  </span><span class="err">host:</span><span class="w"> </span><span class="err">'127.0.0.1',</span><span class="w">
  </span><span class="err">port:</span><span class="w"> </span><span class="err">'4000',</span><span class="w">
  </span><span class="err">netId:</span><span class="w"> </span><span class="err">'127.0.0.1:4000',</span><span class="w">
  </span><span class="err">_identifier:</span><span class="w"> </span><span class="err">'node-xyz-init@127.0.0.1:4000'</span><span class="w"> </span><span class="p">}</span><span class="w">
</span></code></pre>
</div>

<p>Aside from <code class="highlighter-rouge">name</code>, <code class="highlighter-rouge">host</code> and <code class="highlighter-rouge">port</code>, you see two other keys: <strong>netId</strong> which is <code class="highlighter-rouge">[HOST]:[PORT]</code> and <strong>_identifier</strong> which is <code class="highlighter-rouge">[NAME]@[HOST]:[PORT]</code>. The <a href="http://localhost:2000/apidoc/xyz.js.html#line252">source code</a> of this method is:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">id</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">name</span><span class="p">:</span> <span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">name</span><span class="p">,</span>
      <span class="na">host</span><span class="p">:</span> <span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">host</span><span class="p">,</span>
      <span class="na">port</span><span class="p">:</span> <span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">transport</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">port</span><span class="p">,</span>
      <span class="na">netId</span><span class="p">:</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">host</span><span class="p">}:</span><span class="nx">$</span><span class="p">{</span><span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">transport</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">port</span><span class="p">}</span><span class="err">`</span><span class="p">,</span>
      <span class="na">_identifier</span><span class="p">:</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">name</span><span class="p">}</span><span class="err">@</span><span class="nx">$</span><span class="p">{</span><span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">host</span><span class="p">}:</span><span class="nx">$</span><span class="p">{</span><span class="nx">CONFIG</span><span class="p">.</span><span class="nx">getSelfConf</span><span class="p">().</span><span class="nx">transport</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">port</span><span class="p">}</span><span class="err">`</span>
    <span class="p">}</span>
  <span class="p">}</span></code></pre></figure>

<p>As you can see, <code class="highlighter-rouge">SelfConf().transport[0].port</code> is used in both <strong>netId</strong> and <strong>_identifier</strong>.</p>

<p>with this information in mind, we know enough to start manipulating the routes and servers in a xyz node.</p>

<h1 id="using-outgoing-routes">Using outgoing routes</h1>

<p>In order to create a new outgoing route, you can use <code class="highlighter-rouge">xyz.registerClientRoute(prefix, gmwh)</code> function. The spec. of the function is described in the <a href="/apidoc/NodeXYZ.html#registerClientRoute">API DOC</a>. This function accepts two parameters:</p>

<ul>
  <li><strong>prefix</strong>: another name for the <code class="highlighter-rouge">route</code> name.</li>
  <li><strong>[gmwh]</strong>: an instance of the GenericMiddlewareHandler class in xyz-core. This middleware stack will be linked to the new route if defined. If not defined, an empty middleware stack will be linked.</li>
</ul>

<p>Let’s create a simple node and add a new route named <code class="highlighter-rouge">/SECRET</code> to it.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">math</span><span class="p">.</span><span class="nx">registerClientRoute</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">math</span><span class="p">)</span></code></pre></figure>

<p>you should see the output :</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Transport:
  outgoing middlewares:
    call.dispatch.mw <span class="o">[</span>/CALL] <span class="o">||</span> _httpExport[0]
    ping.dispatch.mw <span class="o">[</span>/PING] <span class="o">||</span> _httpExport[0]
    SECRET.dispatch.mw <span class="o">[</span>/SECRET] <span class="o">||</span></code></pre></figure>

<blockquote>
  <p>Note that a <code class="highlighter-rouge">/</code> will be prepended to route name by default</p>
</blockquote>

<p>As you see, <code class="highlighter-rouge">SECRET.dispatch.mw [/SECRET] ||</code> is currently empty. In order to access this middleware and append a function to it we can use the normal <code class="highlighter-rouge">middlewares()</code> syntax that was explained in <a href="/documentations/getting-started/#middlewares">getting-started</a> section:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">function</span> <span class="nx">_msgConfigLogger</span><span class="p">(</span><span class="nx">params</span><span class="p">,</span> <span class="nx">next</span><span class="p">,</span> <span class="nx">end</span><span class="p">,</span> <span class="nx">xyz</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">CONFIG</span> <span class="nx">LOGGER</span> <span class="err">::</span> <span class="nx">$</span><span class="p">{</span><span class="nx">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]}</span><span class="err">`</span><span class="p">)</span>
        <span class="nx">next</span><span class="p">()</span>
<span class="p">}</span>

<span class="nx">math</span><span class="p">.</span><span class="nx">registerClientRoute</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">)</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">client</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">_msgConfigLogger</span><span class="p">)</span></code></pre></figure>

<p>You can now see:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">Transport:
  outgoing middlewares:
    call.dispatch.mw <span class="o">[</span>/CALL] <span class="o">||</span> _httpExport[0]
    ping.dispatch.mw <span class="o">[</span>/PING] <span class="o">||</span> _httpExport[0]
    SECRET.dispatch.mw <span class="o">[</span>/SECRET] <span class="o">||</span> _msgConfigLogger[0]</code></pre></figure>

<p>Of course, this middleware currently does nothing but logging one of its parameters, but that is not the point of this article. Though, let’s insert this middleware into the default <code class="highlighter-rouge">CALL</code> middleware and see the values. As you might remember, <code class="highlighter-rouge">params[2]</code> is the config object of the message.</p>

<p>We also need to register a function in the local node and call it to see middleware in action, otherwise any <code class="highlighter-rouge">.call()</code> will be rejected with a local response.</p>

<blockquote>
  <p>Side note: xyz nodes do NOT distinguish local or remote nodes and services. This means that every node will append itself to <code class="highlighter-rouge">systemConf.nodes[]</code> and will ping itself according to ping mechanism, hence it will discover its own services and can <code class="highlighter-rouge">.call()</code> them.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// register a dummy service</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="p">(</span><span class="nx">payload</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">resp</span><span class="p">.</span><span class="nx">jsonify</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">math</span><span class="p">.</span><span class="nx">registerClientRoute</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">)</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">client</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">_msgConfigLogger</span><span class="p">)</span>

<span class="c1">// insert _msgConfigLogger into the /CALL route</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">client</span><span class="p">(</span><span class="s2">"CALL"</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="mi">0</span> <span class="p">,</span><span class="nx">_msgConfigLogger</span><span class="p">)</span>

<span class="c1">// call it. note that we must wait a sec since service discovery must resolve local node</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">math</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="na">servicePath</span><span class="p">:</span> <span class="s2">"add"</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">7</span><span class="p">}},</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">)</span></code></pre></figure>

<p>If you pay attention to your terminal, you see:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>CONFIG LOGGER :: {"hostname":"127.0.0.1","port":"4000","path":"/CALL","method":"POST","json":{"userPayload":{"x":1,"y":7},"service":"/add"}}
</code></pre>
</div>
<p>The key <code class="highlighter-rouge">path</code> inside this object is a synonym for the route of the message, which is <code class="highlighter-rouge">/CALL</code> be default.</p>

<p>Now let’s see how we can sent a message to another route, using another route middleware</p>

<p>you can add a key named <code class="highlighter-rouge">route</code> to <code class="highlighter-rouge">.call()</code> to indicate the route of the message:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">math</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span><span class="na">servicePath</span><span class="p">:</span> <span class="s2">"add"</span><span class="p">,</span> <span class="na">payload</span><span class="p">:</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">7</span><span class="p">},</span> <span class="na">route</span><span class="p">:</span> <span class="s2">"SECRET"</span><span class="p">},</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span>
<span class="p">})</span></code></pre></figure>

<p>if you run the node now, you see that <code class="highlighter-rouge">path</code> has changed in logger, but the log inside response callback has not been called. This is because <code class="highlighter-rouge">SECRET.dispatch.mw</code> doesn’t export the message. Let’s add xyz’s default _httpExport to this middleware stack:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">_httpExport</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'xyz-core/src/Transport/Middlewares/call/http.export.middleware'</span><span class="p">)</span>

<span class="nx">math</span><span class="p">.</span><span class="nx">registerClientRoute</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">)</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">client</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">_msgConfigLogger</span><span class="p">)</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">client</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nx">_httpExport</span><span class="p">)</span></code></pre></figure>

<p>If we send the same message now, we see that:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">{</span> Error: socket hang up ...</code></pre></figure>

<p>is the output. This is because the destination node of the <code class="highlighter-rouge">call({route: 'SECRET', ...})</code>, which is the local node in this case, does not accept messages over ‘SECRET’. The default behavior of xyz’s built in HTTP server is that it drops requests to unknown routes immediately, hence we see the <code class="highlighter-rouge">socket hang up</code> error in the sender.</p>

<p>In order to allow requests to new routes to be received, we must add this route to the <strong>server routes</strong> which will be explained in the next section.</p>

<h1 id="using-server-routes">Using server routes</h1>

<p>The process and syntax of adding a new server route is fairly similar to how we added an outgoing route, the only difference is that we must indicate which server we want to add the route to. The method to use is <a href="http://localhost:2000/apidoc/NodeXYZ.html#registerServerRoute">xyz.registerServerRoute(port, prefix, [gmwh])</a>.</p>

<p>The first paramter is the port which will identify the server to use and the next two parameters have the same effect as <code class="highlighter-rouge">xyz.registerClientRoute()</code>.</p>

<p>Note that in this section we avoid adding new servers and just manipulate the existing HTTP server on port 4000. In the next section, we will add new servers.</p>

<p>Let’s add the <code class="highlighter-rouge">SECRET</code> route the current node’s  HTTP server and see how the message that we sent before will now arrive successfully.</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// register a new server route</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">registerServerRoute</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> <span class="s1">'SECRET'</span><span class="p">)</span></code></pre></figure>

<p>the output of <code class="highlighter-rouge">console.log(math)</code> will be:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">HTTPServer @ 4000 ::
  Middlewares:
  call.receive.mw <span class="o">[</span>/CALL] <span class="o">||</span> _httpMessageEvent[0]
  ping.receive.mw <span class="o">[</span>/PING] <span class="o">||</span> _pingEvent[0]
  SECRET.receive.mw <span class="o">[</span>/SECRET] <span class="o">||</span></code></pre></figure>

<p>But even now, the message to <code class="highlighter-rouge">add</code> will still not be responded correctly. This is because unlike <code class="highlighter-rouge">/CALL</code>, the <code class="highlighter-rouge">/SECRET</code> (SECRET.receive.mw) is empty and it will not emit any messages up to service layer. This log indicates this problem:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">[</span>node-xyz-init@127.0.0.1:4000] error :: GMWH :: attempting to call SECRET.receive.mw[0] which is not defined. teminating execution...</code></pre></figure>

<p>You can use xyz’s <code class="highlighter-rouge">_httpMessageEvent</code>, which is used in <code class="highlighter-rouge">/CALL</code> be default to patch in the last component needed to complete a message over a new route.</p>

<blockquote>
  <p>Note that <code class="highlighter-rouge">_httpMessageEvent</code> works with the format of messages exported using <code class="highlighter-rouge">_httpExport</code>.</p>
</blockquote>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">_httpMessageEvent</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./../../src/Transport/Middlewares/call/http.receive.event'</span><span class="p">)</span>

<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">server</span><span class="p">(</span><span class="s1">'SECRET'</span><span class="p">)(</span><span class="mi">4000</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">_httpMessageEvent</span><span class="p">)</span>
 </code></pre></figure>

<blockquote>
  <p>When you first saw the syntax of <code class="highlighter-rouge">.middlewares()</code> in getting started, with lots of dots after it, it might have looked a bit strange, but now it should make sense how with each <code class="highlighter-rouge">.</code> and <code class="highlighter-rouge">()</code>, we move into the depth of xyz-core’s layer to reach our desired middleware.</p>
</blockquote>

<p>Finally, at this point the message that you have sent via <code class="highlighter-rouge">/SECRET</code> should be responded successfully.</p>

<p>Note that the burden of creating a new route, middleware and linking them can be encapsulated in a <a href="/documentations/advance/Bootstrap-functions"><strong>Bootstrap Function</strong></a> and this tutorial was to clear the way in detail. Aside from that, keep in mind that several routes are useful only when you want to have different middlewares applied to different messages. As an example, you might want an authentication middleware in <code class="highlighter-rouge">/SECRET</code> route but not in <code class="highlighter-rouge">/CALL</code> route.</p>

<h1 id="using-new-servers">Using new servers</h1>

<p>So far, we have seen how to add routes, both from a client point of view and server point of view. Although, we only added routes to an existing server. We didn’t create another server.</p>

<p>There are two ways to add a server to your xyz node.</p>

<ul>
  <li>using <code class="highlighter-rouge">selfConf.transport[]</code></li>
  <li>using <code class="highlighter-rouge">xyz.registerServer()</code></li>
</ul>

<p>Setting up a new server is just a simple step and the rest of the work has been explained in the previous section. That is to say, once we learn how to create a server on port <code class="highlighter-rouge">X</code>, you can manipulate it and add middlewares to it just as you did with the default server. The only difference is that <code class="highlighter-rouge">X</code> should be used instead of <code class="highlighter-rouge">4000</code> as port.</p>

<p>Before going into the syntax, properties of a server should be explained:
Each server has:</p>

<ul>
  <li>a <strong>port</strong></li>
  <li>a <strong>type</strong>, which can be <code class="highlighter-rouge">HTTP</code>, <code class="highlighter-rouge">UDP</code></li>
  <li>a boolean key named <strong>event</strong> which will indicate wether the Service layer should listen to message events on this server or not. This is crucially important because when a middleware like <code class="highlighter-rouge">_httpMessageEvent</code> sends a message over the server using <code class="highlighter-rouge">_aServer.emit(...)</code>, the serviceRepository should also listen to it with <code class="highlighter-rouge">serviceRepository._aServer.on(...)</code>.</li>
</ul>

<blockquote>
  <p>Transport servers with type <code class="highlighter-rouge">HTTPS</code> and <code class="highlighter-rouge">TCP</code> are being developed.</p>
</blockquote>

<h3 id="creating-a-server-from-configuration">Creating a server from configuration</h3>

<p>The only step needed is to append objects with keys mentioned above to <code class="highlighter-rouge">systemConf</code>:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">math</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XYZ</span><span class="p">({</span>
  <span class="na">selfConf</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">transport</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'HTTP'</span><span class="p">,</span> <span class="na">port</span><span class="p">:</span> <span class="mi">4000</span><span class="p">},</span>
      <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'HTTP'</span><span class="p">,</span> <span class="na">port</span><span class="p">:</span> <span class="mi">5000</span><span class="p">},</span>
      <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'UDP'</span><span class="p">,</span> <span class="na">port</span><span class="p">:</span> <span class="mi">6000</span><span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<p>and you will see the log of <code class="highlighter-rouge">console.log(math)</code>:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">HTTPServer @ 4000 ::
  Middlewares:
  call.receive.mw <span class="o">[</span>/CALL] <span class="o">||</span> _httpMessageEvent[0]
  ping.receive.mw <span class="o">[</span>/PING] <span class="o">||</span> _pingEvent[0]
  SECRET.receive.mw <span class="o">[</span>/SECRET] <span class="o">||</span> _httpMessageEvent[0]

HTTPServer @ 5000 ::
  Middlewares:
  call.receive.mw <span class="o">[</span>/CALL] <span class="o">||</span> _httpMessageEvent[0]

UDPServer @ 6000 ::
  Middlewares:</code></pre></figure>

<p>We do not define <code class="highlighter-rouge">event</code> here, since by default, event will always be considered true, unless explicitly defined <code class="highlighter-rouge">false</code>. To be sure of this, you should always see an <code class="highlighter-rouge">info</code> log at runtime indicating this:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="o">[</span>node-xyz-init@127.0.0.1:4000] info :: SR :: ServiceRepository events bounded <span class="k">for</span> <span class="o">[</span>HTTP] server port 4000
<span class="o">[</span>node-xyz-init@127.0.0.1:4000] info :: SR :: ServiceRepository events bounded <span class="k">for</span> <span class="o">[</span>HTTP] server port 5000
<span class="o">[</span>node-xyz-init@127.0.0.1:4000] info :: SR :: ServiceRepository events bounded <span class="k">for</span> <span class="o">[</span>UDP] server port 6000</code></pre></figure>

<p>As you see, each HTTP server will create one route by default, <code class="highlighter-rouge">/CALL</code>, while UDP server does not have any route.</p>

<p>You are encouraged to start adding routes to both servers and test them, but we aren’t going to do that now since we are going to explain them as an example in the last section of this article.</p>

<h3 id="creating-server-at-runtime">Creating server at runtime</h3>

<p>A method in xyz-core will accept the same three parameters ans has almost the same behavior. An example that justifies why a method was also needed for adding a server is the <a href="">swim ping mechanism</a>. This ping mechanism is isolated in a bootstrap function, although it needs a UDP server and client. Having a method to add a server allows this ping bootstrap function to create new servers and routes <strong>without needing the developer to change a single line of their business logic code or config.</strong></p>

<p>The method spec can be seen <a href="/apidoc/NodeXYZ.html#registerServer">here</a>. Inside your code, you can use it like:</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// add a new server</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">registerServer</span><span class="p">(</span><span class="s1">'UDP'</span><span class="p">,</span> <span class="mi">7000</span><span class="p">)</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">registerServer</span><span class="p">(</span><span class="s1">'HTTP'</span><span class="p">,</span> <span class="mi">8000</span><span class="p">)</span></code></pre></figure>

<p>In the next section, we use this information to demonstrate how you can use these features to enable your nodes to send UDP messages through an entirely separate middleware and route. This can be actually handy because your node might want to send some important messages over HTTP, meanwhile send some less important messages using a UDP tunnel.</p>

<h1 id="wrapping-it-up-a-udp-tunnel">Wrapping it up: a UDP tunnel</h1>

<p>Assume that we need to have a set of microservices which want to communicate with each other over a secure and reliable transport layer, without taking the chance of message drop etc. Meanwhile, our services also need to broadcast messages to <strong>all other nodes</strong> from time to time. Although using HTTP for broadcasting is possible, it does not feel right because it can jam your network due to its high message load and process. In such cases, it is a good Idea to use UDP as the broadcasting transport.</p>

<p>Note that we are going to do everything inside a single node process to keep things simple, but the same rules apply if you want to have this mechanism over multiple nodes. Similar to the previous section, our one microservices is going to call itself, sometimes over HTTP and sometimes over UDP.</p>

<p>Let’s set up the node real quick!</p>

<ul>
  <li>We will add the new UDP server in the config, not using a method:</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">let</span> <span class="nx">math</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XYZ</span><span class="p">({</span>
  <span class="na">selfConf</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">transport</span><span class="p">:</span> <span class="p">[</span>
      <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'HTTP'</span><span class="p">,</span> <span class="na">port</span><span class="p">:</span> <span class="mi">4000</span><span class="p">},</span>
      <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s1">'UDP'</span><span class="p">,</span> <span class="na">port</span><span class="p">:</span> <span class="mi">6000</span><span class="p">}</span>
    <span class="p">]</span>
  <span class="p">}</span>
<span class="p">})</span></code></pre></figure>

<ul>
  <li>We set up to services to be exposed. <code class="highlighter-rouge">add</code> is the important one and <code class="highlighter-rouge">notification</code> is the one that we want to send messages to using UDP</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// a function that need to be called securely and synchronously, with a callback</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">'add'</span><span class="p">,</span> <span class="p">(</span><span class="nx">payload</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">resp</span><span class="p">.</span><span class="nx">jsonify</span><span class="p">(</span><span class="nx">payload</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">payload</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
<span class="p">})</span>

<span class="nx">math</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">'notification'</span><span class="p">,</span> <span class="p">(</span><span class="nx">payload</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">notification</span> <span class="nx">receiver</span> <span class="nx">$</span><span class="p">{</span><span class="nx">payload</span><span class="p">}</span> <span class="p">[</span><span class="nx">resp</span> <span class="nx">$</span><span class="p">{</span><span class="nx">resp</span><span class="p">}]</span><span class="err">`</span><span class="p">)</span>
<span class="p">})</span></code></pre></figure>

<ul>
  <li>We create an outgoing route for UDP messages</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// sender side. we need a udp route</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">registerClientRoute</span><span class="p">(</span><span class="s1">'UDP_BCAST'</span><span class="p">)</span>

<span class="kr">const</span> <span class="nx">_udpExport</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./../../src/Transport/Middlewares/call/udp.export.middleware'</span><span class="p">)</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">client</span><span class="p">(</span><span class="s1">'UDP_BCAST'</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">_udpExport</span><span class="p">)</span></code></pre></figure>

<p>Note that <code class="highlighter-rouge">_udpExport</code> is a middleware function similar to <code class="highlighter-rouge">_httpExport</code>. It will send a message using UDP.</p>

<ul>
  <li>We set up the UDP server properly.</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// receiving side</span>
<span class="c1">// need a UDP server with the same route name</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">registerServerRoute</span><span class="p">(</span><span class="mi">6000</span><span class="p">,</span> <span class="s1">'UDP_BCAST'</span><span class="p">)</span>

<span class="kr">const</span> <span class="nx">_udpMessageEvent</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./../../src/Transport/Middlewares/call/udp.receive.event'</span><span class="p">)</span>
<span class="nx">math</span><span class="p">.</span><span class="nx">middlewares</span><span class="p">().</span><span class="nx">transport</span><span class="p">.</span><span class="nx">server</span><span class="p">(</span><span class="s1">'UDP_BCAST'</span><span class="p">)(</span><span class="mi">6000</span><span class="p">).</span><span class="nx">register</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">_udpMessageEvent</span><span class="p">)</span></code></pre></figure>

<p>By this point, when you run the node you should see this in <code class="highlighter-rouge">console.log(math)</code></p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">____________________  TRANSPORT LAYER ____________________
Transport:
  outgoing middlewares:
    call.dispatch.mw <span class="o">[</span>/CALL] <span class="o">||</span> _httpExport[0]
    ping.dispatch.mw <span class="o">[</span>/PING] <span class="o">||</span> _httpExport[0]
    UDP_BCAST.dispatch.mw <span class="o">[</span>/UDP_BCAST] <span class="o">||</span> _udpExport[0]

  HTTPServer @ 4000 ::
    Middlewares:
    call.receive.mw <span class="o">[</span>/CALL] <span class="o">||</span> _httpMessageEvent[0]
    ping.receive.mw <span class="o">[</span>/PING] <span class="o">||</span> _pingEvent[0]

  UDPServer @ 6000 ::
    Middlewares:
    UDP_BCAST.receive.mw <span class="o">[</span>/UDP_BCAST] <span class="o">||</span> _udpEvent[0]</code></pre></figure>

<p>Seems correct.</p>

<ul>
  <li>Finally, we write the code to send messages</li>
</ul>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="c1">// default call</span>
<span class="nx">setTimeout</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">math</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span>
    <span class="na">servicePath</span><span class="p">:</span> <span class="s1">'add'</span><span class="p">,</span>
    <span class="na">payload</span><span class="p">:</span> <span class="p">{</span><span class="na">x</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="na">y</span><span class="p">:</span> <span class="mi">7</span><span class="p">}</span>
  <span class="p">},</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">body</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">add</span> <span class="o">=&gt;</span> <span class="nx">$</span><span class="p">{</span><span class="nx">err</span><span class="p">},</span> <span class="nx">$</span><span class="p">{</span><span class="nx">body</span><span class="p">}</span><span class="err">`</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">},</span> <span class="mi">5000</span><span class="p">)</span>

<span class="c1">// broadcast call</span>
<span class="c1">// will use a new send strategy and udp</span>
<span class="kr">const</span> <span class="nx">_broadcastGlobal</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'./../../src/Service/Middleware/service.broadcast.global'</span><span class="p">)</span>
<span class="nx">setInterval</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">math</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span>
    <span class="na">servicePath</span><span class="p">:</span> <span class="s1">'notification'</span><span class="p">,</span>
    <span class="na">payload</span><span class="p">:</span> <span class="s1">'STH HAPPENED!'</span><span class="p">,</span>
    <span class="na">sendStrategy</span><span class="p">:</span> <span class="nx">_broadcastGlobal</span><span class="p">,</span>
    <span class="na">route</span><span class="p">:</span> <span class="s1">'UDP_BCAST'</span>
  <span class="p">},</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'sender'</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">},</span> <span class="mi">1000</span><span class="p">)</span></code></pre></figure>

<p>As you see, in the second <code class="highlighter-rouge">.call()</code> we are using <code class="highlighter-rouge">_broadcastGlobal</code> as sendStrategy. This middleware will broadcast the message to all nodes in the system, <strong><em>regardless of the path of the service</em></strong>. Also, we are using <code class="highlighter-rouge">UDP_BCAST</code> as the outgoing route, so that the message will be sent over UDP.</p>

<p>We are ready to lunch! Run the node process.</p>

<p>You should notice that the only log the we are seeing is</p>

<ol>
  <li><code class="highlighter-rouge">add</code> bing called, logging <code class="highlighter-rouge">add =&gt; null, 8</code> every 5 second</li>
  <li>sender callback of <code class="highlighter-rouge">notification</code>, logging <code class="highlighter-rouge">sender null { '127.0.0.1:4000:/notification': [ null, '86 bytes sent' ] }</code></li>
</ol>

<p>The first log is as we expect. But the second one seems flawed. One thing that you should keep in mind is that UDP messages are <strong><em>Asynchronous</em></strong>, meaning that the sender will not wait for their response. In other words, the second argument of <code class="highlighter-rouge">.call()</code> when udp export is being used is not the response of the callee, its just a callback indicating that <strong>the messages has been successfully sent</strong>. We don’t whether it has been received or not, and we don’t wait for the callee to respond. This is the nature of UDP, right?</p>

<p>So, apparently the second log is also rationale. The main problem now is that</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">math</span><span class="p">.</span><span class="nx">register</span><span class="p">(</span><span class="s1">'notification'</span><span class="p">,</span> <span class="p">(</span><span class="nx">payload</span><span class="p">,</span> <span class="nx">resp</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="err">`</span><span class="nx">notification</span> <span class="nx">receiver</span> <span class="nx">$</span><span class="p">{</span><span class="nx">payload</span><span class="p">}</span> <span class="p">[</span><span class="nx">resp</span> <span class="nx">$</span><span class="p">{</span><span class="nx">resp</span><span class="p">}]</span><span class="err">`</span><span class="p">)</span>
<span class="p">})</span></code></pre></figure>

<p>is never being called.</p>

<p>We can give you the answer and the missing part right away, but let’s use this problem as an excuse to debug an xyz node.</p>

<p>One good way to debug xyz is to reduce the log level to basic matters (<a href="">Logging is explained with more detail in a different page</a>). xyz used <strong>info</strong> log level by default. You can verify this by seeing the <code class="highlighter-rouge">logLevel</code> field in <code class="highlighter-rouge">selfConf</code>. As a first step, let’s reduce log level to verbose. Furthermore, let’s not touch a single line of code and used command line arguments to change to log level. Run the node with <code class="highlighter-rouge">$ node math.ms.js --xyz-logLevel verbose</code></p>

<p>New messages will pop out. Let’s investigate them.</p>

<ul>
  <li>
    <p>Every 5 second, you see:</p>

    <p><code class="highlighter-rouge">verbose :: FIRST FIND :: determined node for service /add by first find strategy : 127.0.0.1:4000:/add </code>. This the main HTTP message being routed to <code class="highlighter-rouge">127.0.0.1:4000</code> for service <code class="highlighter-rouge">/add</code>.</p>

    <p>Immediately afterwards, you should see</p>

    <p><code class="highlighter-rouge">verbose :: SR :: ServiceRepository received message for service  /add</code>.</p>

    <p>This is the receiving side of the message, after the message has been sent over the local network to <code class="highlighter-rouge">127.0.0.1:4000</code> (which is ironically the sender in this  case).</p>

    <p>And after that you should see</p>

    <p><code class="highlighter-rouge">add =&gt; null, 8</code></p>
  </li>
  <li>
    <p>Every 1 second you should see:</p>

    <p><code class="highlighter-rouge">verbose :: BROADCAST GLOBAL :: sending message to 127.0.0.1:4000:/notification</code></p>

    <p>which is the broadcast middleware doing what is was supposed to do.</p>
  </li>
</ul>

<p>So where is the flaw? You should keep in mind that the <code class="highlighter-rouge">BROADCAST GLOBAL</code> is doing its job correctly. It is a <strong>Service middleware</strong> and from the service point of view <strong><em>a node with identifier 127.0.0.1:4000 is the target of /notification</em></strong>.</p>

<p>Let’s reduce the logLevel to <code class="highlighter-rouge">debug</code> and see the problem. We will only focus on the logs before <code class="highlighter-rouge">sender null { '127.0.0.1:4000:/notification': [ null, '86 bytes sent' ] }</code> which are related to udp messages.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">verbose :: BROADCAST GLOBAL :: sending message to 127.0.0.1:4000:/notification,   
debug :: Transport Client :: sending message to 127.0.0.1:4000/UDP_BCAST through UDP_BCAST.dispatch.mw middleware
sender null <span class="o">{</span> <span class="s1">'127.0.0.1:4000:/notification'</span>: <span class="o">[</span> null, <span class="s1">'86 bytes sent'</span> <span class="o">]</span> <span class="o">}</span></code></pre></figure>

<p>Although the service layer was doing its job correct, you can now see that the <strong>Transport layer is not</strong>. This is because Transport layer, unlike service layer is not independent of the Transport mechanism and should not rely on the <strong>identifier</strong>. In the debug log we are seeing that the message is being sent to port <strong>4000</strong> of the receiver (<code class="highlighter-rouge">sending message to 127.0.0.1:4000/UDP_BCAST through UDP_BCAST.dispatch.mw middleware</code>). In other words, the message is being sent to <strong>the wrong port of the correct node</strong>.</p>

<p>This issue is because xyz nodes are allowed to have multiple servers, hence multiple ports, meanwhile they should have <strong>just one identifier for the service layer</strong>. Hopefully, it has been mentioned <a href="">in the spec. of ping mechanisms</a> that one of their duties is to keep track of each node’s routes and servers. This can enable Transport layer to automatically fix this issue. But, the Transport layer will do so only when you <strong>tell it to do so</strong>. How? let’s see.</p>

<h3 id="message-redirect">Message redirect</h3>

<p>To solve the issue we can use the <code class="highlighter-rouge">redirect</code> optional key in <code class="highlighter-rouge">.call()</code> This key, if defined <code class="highlighter-rouge">true</code> will <strong>Double check the message route with the destination port determined by the service layer</strong>. In other words, if the sendStrategy determined that <code class="highlighter-rouge">192.168.0.15:7000</code> is the target node of a message, the transport layer will not blindly send the message to <code class="highlighter-rouge">192.168.0.15:7000</code>. It will check the message’s <strong>route</strong> and see which server of <code class="highlighter-rouge">192.168.0.15</code>, on which port, has a accepting route that matches the messages route.</p>

<p>If you imagine what <code class="highlighter-rouge">redirect</code> is doing, it’s not hard to infer this constrain on routes to keep <code class="highlighter-rouge">redirect</code> working:</p>

<blockquote>
  <p><strong>All routes</strong> of <strong>all servers within a node</strong> should be <strong>unique</strong>. As a counterpart, assume that a node with identifier X.Y.Z.Q:3000 has has route <code class="highlighter-rouge">FOO</code> in both X.Y.Z.Q:4000 and X.Y.Z.Q:5000. can <code class="highlighter-rouge">redirect</code> decide correctly?</p>
</blockquote>

<p>Change the sender of the message to</p>

<figure class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">math</span><span class="p">.</span><span class="nx">call</span><span class="p">({</span>
    <span class="na">servicePath</span><span class="p">:</span> <span class="s1">'notification'</span><span class="p">,</span>
    <span class="na">payload</span><span class="p">:</span> <span class="s1">'STH HAPPENED!'</span><span class="p">,</span>
    <span class="na">sendStrategy</span><span class="p">:</span> <span class="nx">_broadcastGlobal</span><span class="p">,</span>
    <span class="na">route</span><span class="p">:</span> <span class="s1">'UDP_BCAST'</span><span class="p">,</span>
    <span class="na">redirect</span><span class="p">:</span> <span class="kc">true</span>
  <span class="p">},</span> <span class="p">(</span><span class="nx">err</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'sender'</span><span class="p">,</span> <span class="nx">err</span><span class="p">,</span> <span class="nx">msg</span><span class="p">)</span>
  <span class="p">})</span></code></pre></figure>

<p>and launch again. As you see, the receiver log (<code class="highlighter-rouge">console.log('notification receiver ${payload} [resp ${resp}]')
</code>) will be resolved to</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">receiver STH HAPPENED! <span class="o">[</span>resp undefined]</code></pre></figure>

<p>The fact that <code class="highlighter-rouge">resp</code> is <code class="highlighter-rouge">undefined</code> further proves that udp messages are async. In other words, you can not respond to the directly since the sender is not waiting for any response. So, no <code class="highlighter-rouge">resp.send</code> or <code class="highlighter-rouge">resp.jsonify</code> in this case.</p>

<hr />

<p>We are done with this tutorial! You can find more information in API doc of classes that are relevant to this topic, such as</p>

<ul>
  <li><a href="">Transport</a></li>
  <li><a href="">ServiceRepository</a></li>
  <li><a href="">HTTPServer</a></li>
  <li><a href="">UDPServer</a></li>
  <li><a href="">_httpExport</a></li>
  <li><a href="">_httpMessageEvent</a></li>
</ul>

<p>The code of this tutorial is tested and maintained <a href="">here</a></p>

  </div>
</div>

<script type="text/javascript">
var side = $("#___side")
var $side = $('#___side > ol')
var heads = $('h1')
function getSideBarElem(name, id) {
  return `<li>
    <a href="#${id}">
      ${name.replace(/-/g, ' ')}
    </a>
  </li>`
}
$.each( heads, function(idx, elem) {
  $side.append(getSideBarElem($(elem).html(), elem.id))
})

// $("#__side").css('width', $("#__side").parent().width() + 'px')

</script>


  </section>
  
<style media="screen">
  .site-footer{
    padding: 30px;
    color: var(--light-color);
    background-color: var(--very-dark);
    margin-top: 40px;
  }
</style>
<footer class="site-footer">
  <span class="site-footer-owner">
    <a href="http://localhost:1999">NODE XYZ</a>
     is maintained by <a href="">Kian Peymani & Ajand </a></span>
  <small>
    <br>
    <span class="site-footer-credits">This page was generated and hosted by <a href="https://pages.github.com">GitHub Pages</a></small>
</footer>

  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" charset="utf-8"></script>

</body>
</html>

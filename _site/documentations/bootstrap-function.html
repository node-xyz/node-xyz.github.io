<!DOCTYPE html>
<html lang="en-us">
  
  <head>
  <meta charset="UTF-8">
  <title>Node XYZ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#157878">
  <link rel="stylesheet" href="/css/normalize.css">
  <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="/css/cayman.css">
</head>


  <body>
    <section class="page-header">
  <h1 class="project-name"><a style="text-decoration: none; color: inherit"href="/">Node XYZ</a></h1>
  <h2 class="project-tagline">Microservice toolkit for node</h2>
  <a href="https://github.com/node-xyz" class="btn">View on GitHub</a>
  <a href="/documentations" class="btn"> Documentation </a>
  <a href="/apidoc" class="btn"> API Doc </a>

  <div>
    <span>you are currently seeing </span><strong>Bootstrap function</strong>
  </div>
  
</section>


    <section class="main-content">
      
      <h1 id="bootstrap-functions">Bootstrap functions</h1>

<p>Configuring an xyz instance can sometimes be annoying. Many nodes want to have the same configurations, same middlewares etc, but is is good to copy and paste a chunk of code in all of these microservices? I mean, think about it, Aside from <code class="highlighter-rouge">.register</code> which creates new endpoints for functions, there is a good chance that most of the lines of the microservices that you are writing are the same among all of the microservices in that application/project. One of the ways to encapsulate these common steps in an isolated environment so that they can be reused is <strong>Bootstrap function</strong>.</p>

<p>Bootstrap functions are… nothing in fact. They’re just functions that take in the current xyz instance as argument and are free to make any modifications to it. This can include <code class="highlighter-rouge">exposing new functions</code>, listening to <code class="highlighter-rouge">events</code>, registering new <code class="highlighter-rouge">middlewares</code> etc.</p>

<p>A complete example of this is the <a href="https://github.com/node-xyz/xyz.monitor.basic.bootstrap">Monitor Bootstrap function</a>. Let’s have a closer look at this bootstrap function:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>let express = require('express')
let monitorCallReceive = require('./middleware/xyz.monitor.call.receive.middleware')
let monitorCallSend = require('./middleware/xyz.monitor.call.send.middleware')
let load = { snd: 0, rcv: 0}
let logger

function basicMonitorBootstrap (xyz, port = 5000) {
  /*
  Initialize a simple express server
   */
  logger = xyz.logger
  var app = express()
  app.use(express.static(__dirname + '/lib'))

  app.get('/', function (req, res) {
    res.sendFile(__dirname + '/index.html')
  })

  app.get('/all', function (req, res) {
    res.json({load: load, inspectJSON: xyz.inspectJSON(), inspect: xyz.inspect()})
  })
  app.listen(port, function () {
    logger.info(`monitor server started at port ${port}`)
  })

  /*
  Register required middlewares
   */
  xyz.serviceRepository.transportServer.callReceiveMiddlewareStack.register(0,
    monitorCallReceive)
  xyz.serviceRepository.transportClient.callDispatchMiddlewareStack.register(0,
    monitorCallSend)
}

module.exports = {
  bootstrap: basicMonitorBootstrap,
  setSendLoad: (aLoad) =&gt; {
    load.snd = aLoad
  },
  setRcvLoad: (aLoad) =&gt; {
    load.rcv = aLoad
  }
}
</code></pre>
</div>

<ul>
  <li>It can be seen that every bootstrap module must return a function (the actual bootstrap function) that takes the <code class="highlighter-rouge">xyz</code> object as an argument. In this case, this bootstrap function exports <code class="highlighter-rouge">bootstrap: basicMonitorBootstrap</code> which will be later used to apply this bootstrap function.</li>
  <li>Inside a bootstrap function, you are allowed to do almost any thing. In this case, we are creating a very simple express server to serve a single html file and a json API and we are registering two new middlewares inside the system.</li>
  <li>Note that theses two middlewares that we are exposing will later on used
    <div class="highlighter-rouge"><pre class="highlight"><code>setSendLoad: (aLoad) =&gt; {
  load.snd = aLoad
},
setRcvLoad: (aLoad) =&gt; {
  load.rcv = aLoad
}
</code></pre>
    </div>
    <p>to set an estimate value for the load on the node. These values will then be served through the HTTP server.</p>
  </li>
</ul>

<p>So, given that this bootstrap function is written once, you can always use it inside any of your microservices with just one (or two, including the <code class="highlighter-rouge">require</code> statement) line of code:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>let xyzMonitor = require('./../xyz.monitor.basic.bootstrap')
let mathMs = new XYZ({
  selfConf: {...},
  systemConf: { nodes: []}
})

xyzMonitor.bootstrap(mathMs, 7000)

</code></pre>
</div>

<p>There is complete example of this <a href="https://github.com/node-xyz/xyz.monitor.basic.bootstrap/tree/master/example">here</a>. After you set up this bootstrap function, you can view a nice monitoring page at your localhost (and on port <code class="highlighter-rouge">7000</code> in this case):</p>

<p><img src="/assets/monitor.png" alt="example monitor app" /></p>


      <footer class="site-footer">
  <span class="site-footer-owner"><a href="http://localhost:4000">Node XYZ</a> is maintained by <a href="">Kian Peymani</a>.</span>
  <small><span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/pietromenna/jekyll-cayman-theme">Cayman theme</a> by <a href="http://github.com/jasonlong">Jason Long</a>.</span></small>
</footer>


    </section>

  </body>
</html>
